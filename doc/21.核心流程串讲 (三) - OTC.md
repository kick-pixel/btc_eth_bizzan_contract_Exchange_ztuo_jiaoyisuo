# 核心流程串讲 (三) - OTC 与 CTC 交易

## 1. 概念阐述：OTC 与 CTC

在深入探讨业务流程之前，我们首先需要明确系统中两种主流的法币交易模式：OTC（Over-the-Counter）和 CTC（Customer-to-Customer）。尽管两者都涉及法币与数字货币的兑换，但它们在业务模型、用户体验和后端实现上存在显著差异。

### 1.1. OTC (Over-the-Counter) 交易

OTC，即场外交易，是一个完全的 **C2C（Customer-to-Customer）** 交易市场。其核心思想是为用户提供一个类似“淘宝”或“闲鱼”的平台，让用户可以自由地发布买卖数字货币的广告，并与其他用户点对点地进行交易。

- **业务模型**:
    - **广告驱动**: 交易由“广告”发起。持有数字货币的认证商家可以发布“卖出广告”，希望用法币购买数字货币的用户可以发布“买入广告”。
    - **价格灵活**: 广告发布者可以设定固定价格，也可以设置一个基于市场价浮动的溢价率。
    - **自由匹配**: 用户可以在“广告大厅”浏览所有挂单，根据价格、数量、支付方式和商家信誉等因素，自由选择交易对手。
    - **平台角色**: 平台主要扮演信息撮合、资金托管（Escrow）和争议仲裁的角色。

- **前端体验**:
    - 用户端 (`05_Web_Front_too`): 包含“法币交易”入口，展示一个广告列表（广告大厅），用户可以筛选并选择广告进行下单。
    - 商家端 (`04_bizzan_web_admin`): 认证商家拥有发布和管理自己广告的后台界面。

- **后端服务**:
    - 由独立的微服务 **`otc-api`** 全权负责，处理所有与广告、订单、支付、放行和申诉相关的逻辑。

### 1.2. CTC (Customer-to-Customer) 交易

CTC，虽然字面意思也是客户对客户，但在本系统中的实现更偏向于一种 **B2C（Business-to-Customer）或“平台严选商家”** 的模式。它为用户提供了更简单、快捷的“一键买币/卖币”体验。

- **业务模型**:
    - **平台定价**: 交易价格由平台参考主流市场（如火币、币安）的实时价格，并结合一定的算法（例如，在市场价基础上增加或减少一个固定的点差）后统一设定。
    - **对手指定**: 用户的交易对手是平台指定的、经过严格筛选的“承兑商”（Acceptor），而非普通用户。系统会自动将用户的订单匹配给一个或多个承兑商。
    - **流程简化**: 用户无需浏览广告和筛选商家，只需输入希望买入或卖出的数量，平台即可为其生成订单。

- **前端体验**:
    - 用户端 (`05_Web_Front_too`): 通常表现为一个独立的“快捷买币”或“C2C交易”页面，界面非常简洁，只有买/卖、币种、数量等核心输入框。

- **后端服务**:
    - 核心逻辑位于 **`ucenter-api`**（用户中心）微服务中。这一定位表明，CTC 被视为用户资产操作的一项基础功能，而非一个独立的交易市场。

### 1.3. 核心区别总结

| 特性 | OTC (场外交易) | CTC (快捷交易) |
| :--- | :--- | :--- |
| **业务模型** | 完全 C2C，用户间自由交易 | B2C 或 平台指定商家的 C2C |
| **交易对手** | 普通用户、认证商家 | 平台指定的承兑商 |
| **价格机制** | 用户自主定价（固定或浮动） | 平台参考市场价统一定价 |
| **用户体验** | 复杂，需筛选广告和商家 | 简单，一键买卖 |
| **后端服务** | `otc-api` (独立市场服务) | `ucenter-api` (用户核心功能) |
| **适用场景** | 大额交易、专业用户、价格敏感型用户 | 小额交易、新手用户、追求效率的用户 |

## 2. 核心业务流程分析

### 2.1. OTC 交易流程

OTC 交易的核心围绕 **“广告” (Advertise)** 和 **“订单” (Order)** 展开。

#### 2.1.1. 发布广告 (商家操作)

1.  **前端请求**: 认证商家在 `04_bizzan_web_admin` 或 `05_Web_Front_too` 的广告发布页面 (`AdPublish.vue`) 填写广告详情（币种、类型、价格、限额、支付方式等），提交表单。
2.  **后端处理**: 请求被发送到 `otc-api` 的 `AdvertiseController.java`。
    - **接口**: `POST /advertise/create`
    - **核心逻辑**:
        - **权限校验**: 检查用户是否为认证商家 (`member.getMemberLevel().equals(MemberLevelEnum.IDENTIFICATION)`)。
        - **资金密码验证**: 验证用户的交易密码。
        - **支付方式校验**: 确保用户已绑定所选的支付方式（如支付宝、微信、银行卡）。
        - **余额检查 (卖出广告)**: 如果是卖币广告，系统会检查商家钱包 (`MemberWallet`) 中对应币种的可用余额是否充足。
        - **广告入库**: 创建 `Advertise` 实体并存入数据库，初始状态为“已下架” (`PUT_OFF_SHELVES`)。

#### 2.1.2. 上架广告 (商家操作)

1.  **前端请求**: 商家在广告管理列表中，点击“上架”。
2.  **后端处理**: 请求到达 `otc-api` 的 `AdvertiseController.java`。
    - **接口**: `POST /advertise/on/shelves`
    - **核心逻辑**:
        - **资产冻结 (卖出广告)**: 如果是卖币广告，系统会调用 `memberWalletService.freezeBalance()` 方法，将广告所需的数字货币数量从商家的可用余额划转至冻结余额。这是为了确保商家有币可卖，防止超卖。
        - **状态更新**: 将广告状态更新为“上架中” (`PUT_ON_SHELVES`)。

#### 2.1.3. 用户下单 (买家/卖家操作)

1.  **前端请求**: 普通用户在 `05_Web_Front_too` 的广告大厅 (`otc/index.vue`) 选择一个合适的广告，输入交易数量/金额，点击“下单”。
2.  **后端处理**: 请求被发送到 `otc-api` 的 `OrderController.java`。
    - **接口**: `POST /order/buy` (用户向商家买币) 或 `POST /order/sell` (用户向商家卖币)。
    - **核心逻辑**:
        - **广告状态校验**: 确保广告仍处于“上架中”状态。
        - **价格校验**: 如果广告是浮动价格，后端会重新计算当前市价并验证价格是否在有效范围内，防止“价格过期”。
        - **限额校验**: 检查订单金额是否在广告的最小和最大交易限额之间。
        - **库存扣减**: 调用 `advertiseService.updateAdvertiseAmountForBuy()`，乐观地减少广告的剩余可交易数量 (`remainAmount`)。
        - **资产冻结 (用户卖币)**: 如果是用户卖币给商家，此时会冻结用户钱包中相应数量的币。
        - **订单创建**: 生成 `Order` 实体，状态为“未付款” (`NONPAYMENT`)，并存入数据库。
        - **通知**: 可通过短信或系统消息通知对手方有新订单生成。

#### 2.1.4. 付款与放行

1.  **买家付款**: 买家根据订单显示的收款信息，通过线下方式（如支付宝、银行转账）完成付款，然后在订单页面点击“我已付款”。
    - **后端接口**: `POST /order/pay` (`OrderController.java`)
    - **逻辑**: 将订单状态更新为“已付款” (`PAID`)。

2.  **卖家确认收款并放行**: 卖家确认收到法币后，在订单页面输入交易密码，点击“放行”。
    - **后端接口**: `POST /order/release` (`OrderController.java`)
    - **核心逻辑**:
        - **交易密码验证**: 验证卖家的交易密码。
        - **订单状态校验**: 确保订单处于“已付款”状态。
        - **资产划转**: 这是最核心的一步。调用 `memberWalletService.transfer()` 方法，执行资产的转移。
            - **对于卖币广告**: 将卖家之前被冻结的币，解冻并划转给买家。
            - **对于买币广告**: 将买家之前被冻结的币，解冻并划转给卖家。
        - **更新订单状态**: 将订单状态更新为“已完成” (`COMPLETED`)。
        - **更新广告数量**: 调用 `advertiseService.updateAdvertiseAmountForRelease()`，更新广告的已成交数量。
        - **记录流水**: 在 `MemberTransaction` 表中为双方生成交易流水。

### 2.2. CTC 交易流程

CTC 流程被大大简化，核心是 **“下单” (Order)**。

1.  **前端请求**: 用户在 `05_Web_Front_too` 的快捷买币页面 (`ctc/Ctc.vue`) 输入希望买/卖的币种和数量，选择支付方式，输入资金密码和验证码后提交。
2.  **后端处理**: 请求被发送到 `ucenter-api` 的 `CtcController.java`。
    - **接口**: `POST /ctc/new-ctc-order`
    - **核心逻辑**:
        - **权限与密码验证**: 与 OTC 类似，检查用户的实名状态、交易权限和资金密码。
        - **价格获取**: 通过 `RestTemplate` 调用 `market` 微服务的内部接口 (`http://bitrade-market/market/exchange-rate/usdtcny`) 获取基准价。然后根据买卖方向应用不同的点差，生成最终成交价。
        - **匹配承兑商**: 调用 `ctcAcceptorService.findByStatus(1)` 获取一个当前可用的承兑商。
        - **资产冻结 (用户卖币)**: 如果是卖币，调用 `memberWalletService.freezeBalance()` 冻结用户钱包中的币。
        - **订单创建**: 生成 `CtcOrder` 实体，并直接将承兑商的信息（包括收款账户）写入订单。
            - **买币订单**: 状态直接设为 `1` (已接单)，等待用户付款。
            - **卖币订单**: 状态设为 `0` (待接单)，等待承兑商处理。
        - **通知**: 订单生成后，可能会通过短信或邮件通知承兑商或平台管理员有新订单需要处理。

3.  **后续流程**:
    - **用户付款**: 用户付款后，点击“我已付款”，请求 `POST /ctc/pay-ctc-order` 接口。
    - **承兑商放行**: 承兑商在后台系统（`admin` 模块）看到已付款订单后，进行确认和放行操作。放行逻辑会解冻并划转资产，将订单标记为“已完成”。（这部分逻辑在 `admin` 模块的控制器中）。

## 3. 总结

OTC 和 CTC 共同构成了平台法币交易的完整解决方案。OTC 提供了高度的灵活性和市场深度，满足了专业用户的需求；而 CTC 则以其极致的便捷性，降低了新用户的入门门槛。两者在技术实现上通过不同的微服务进行了隔离，保证了系统的模块化和可扩展性。

# 第八章：WebSocket 实时消息推送：AQMD-NETTY 框架

## 开篇：构建交易所的实时数据动脉

在金融交易系统中，数据的实时性是生命线。用户需要毫秒级感知的行情变化、盘口深度和成交记录。传统的 HTTP 请求/响应模式无法满足这种需求，因为它本质上是客户端拉取（Pull）模型，存在延迟高、资源浪费等问题。

为了实现服务器主动推送（Push），本项目采用了 **WebSocket** 技术。WebSocket 在客户端和服务器之间建立了一条持久化的全双工通信信道，允许数据实时、双向地流动。

为追求极致性能和底层控制力，本项目并未直接使用 Spring Boot 内置的 WebSocket 实现，而是选择了一个基于 **Netty** 的高性能自定义应用层框架——**AQMD-NETTY**。本章将深入剖析该框架的设计与实现，并结合 `market` 服务的源码，阐明实时数据是如何从服务端主动脉，精准地输送到每个客户端的。

---

### 第一节：为何需要 WebSocket？—— “打电话”与“写信”的区别

在深入框架之前，我们必须理解为何实时通信场景必须使用 WebSocket。

*   **HTTP (超文本传输协议)**：就像是**写信**。客户端（你）给服务器（朋友）写一封信（发送一个 Request），然后必须等待朋友回信（Response）。如果你想知道朋友的最新动态，只能不断地写信去问，这既不及时，也浪费资源。这就是所谓的**“轮询 (Polling)”**。

*   **WebSocket**：则像是**打电话**。一旦客户端和服务器之间建立了连接（电话接通），双方就拥有了一条**持久化、全双工**的通话线路。任何一方都可以随时主动向对方说话，信息可以即时传递。在交易所场景，这意味着服务器一旦有了最新的行情，就可以立刻“喊”给所有在线的客户端，而无需等待客户端来问。

正是这种从“拉取”到“推送”的根本性转变，使得 WebSocket 成为构建实时 Web 应用的基石。

---

### 第二节：AQMD-NETTY 框架的设计哲学——封装复杂性

直接使用 Netty 进行网络编程虽然性能强大，但非常复杂，需要开发者手动处理编解码、心跳、线程管理等大量底层细节。`AQMD-NETTY` 框架的核心设计哲学，就是**将这些复杂性进行封装，为上层业务开发提供一套简洁、高效的 API**。

正如 `doc/QA.md` 中所总结的，该框架借鉴了 Spring 的设计思想，通过**注解驱动** (`@HawkBean`, `@HawkMethod`) 和**发布/订阅模型** (`HawkPushServiceApi`, `NettyCacheUtils`)，让开发者可以像开发普通 Web 接口一样，专注于处理订阅、取消订阅等业务逻辑，而将底层的网络通信、`Channel` 管理、消息广播等繁重工作交由框架自动完成。

---

### 第三节：AQMD-NETTY 框架核心组件解析

AQMD-NETTY 是一个基于 Netty 封装的应用层框架，它通过注解和命令分发，极大地简化了 Netty 的开发。

| 核心组件 | 职责 | 说明 |
| :--- | :--- | :--- |
| **`NettyCommand.java`** | **命令协议字典** | 定义了客户端与服务端通信的所有命令码（`cmd`），是一个 `int` 类型的常量集合。例如 `SUBSCRIBE_EXCHANGE = 2001`。 |
| **`@HawkBean`** | **请求处理器** | 类似于 Spring 的 `@Component`，用于标记一个类是 WebSocket 请求的处理器。 |
| **`@HawkMethod`** | **命令映射** | 类似于 Spring 的 `@RequestMapping`，用于将处理器中的一个方法与一个具体的 `cmd` 绑定。 |
| **`HawkPushServiceApi`** | **推送服务接口** | 提供一个统一的、解耦的服务接口，让业务代码（如 Kafka 消费者）可以向客户端推送消息，而无需关心 Netty 底层细节。 |
| **`NettyCacheUtils`** | **内存订阅中心** | 负责存储和管理客户端（`Channel`）与订阅主题（`Topic`）之间的关系，是实现精准推送和广播的基础。 |

---

### 第四节：核心处理器 `NettyHandler` 源码剖析

`market` 模块中的 `com.bizzan.bitrade.handler.NettyHandler` 是 WebSocket 功能的心脏，它同时扮演了**请求处理器**和**数据推送器**两个角色。

#### 2.1 作为请求处理器：处理客户端订阅

当客户端希望接收某个交易对的行情时，它会发送一个“订阅”命令。`NettyHandler` 中相应的方法会被触发，完成订阅逻辑。

*   **客户端请求示例 (JavaScript)**:
    ```javascript
    // 客户端构建一个 JSON 对象，包含命令码和数据体
    let subRequest = {
        cmd: 2001, // 对应 NettyCommand.SUBSCRIBE_EXCHANGE
        body: {
            symbol: "BTC/USDT",
            uid: "1001" // 可选，用于订阅私有消息
        }
    };
    // 通过 WebSocket 发送
    websocket.send(JSON.stringify(subRequest));
    ```

*   **服务端处理方法 (`subscribeExchange`)**:
    ```java
    // com.bizzan.bitrade.handler.NettyHandler
    
    @HawkBean
    public class NettyHandler {
    
        @HawkMethod(cmd = NettyCommand.SUBSCRIBE_EXCHANGE)
        public SimpleResponse subscribeExchange(byte[] body, ChannelHandlerContext ctx) {
            // 1. 解析客户端发来的数据体
            JSONObject json = JSON.parseObject(new String(body));
            String symbol = json.getString("symbol");
            String uid = json.getString("uid");
    
            // 2. 订阅公共主题 (e.g., "BTC/USDT")，用于接收K线、盘口等
            subscribeTopic(ctx.channel(), symbol);
    
            // 3. 如果 uid 存在，则额外订阅一个私有主题 (e.g., "BTC/USDT-1001")
            // 用于接收该用户在该交易对下的个人订单成交、撤销等私有信息
            if (StringUtils.isNotEmpty(uid)) {
                subscribeTopic(ctx.channel(), symbol + "-" + uid);
            }
    
            // 4. 构建并返回一个响应给客户端，告知订阅成功
            return SimpleResponse.newBuilder().setCode(0).setMessage("订阅成功").build();
        }
    
        // 内部方法，负责将 Channel 和 Topic 的关系存入 NettyCacheUtils
        private void subscribeTopic(Channel channel, String topic) {
            // ... (核心逻辑是调用 NettyCacheUtils.storeChannel(topic, channel))
        }
    }
    ```
*   **订阅关系管理**: `subscribeTopic` 方法的核心是调用 `NettyCacheUtils.storeChannel(topic, channel)`。`NettyCacheUtils` 内部维护了类似 `ConcurrentHashMap<String, Set<Channel>>` 的结构，将主题和订阅该主题的客户端 `Channel` 集合关联起来。

#### 2.2 作为数据推送器：被业务逻辑调用

`NettyHandler` 中的 `handle` 方法**并未被 `@HawkMethod` 注解**，它们是暴露给内部其他业务组件（主要是 Kafka 消费者）调用的接口，用于执行最终的数据推送。

*   **端到端“订阅-推送”全流程**:
    ```mermaid
    sequenceDiagram
        participant Client as 客户端
        participant Handler as NettyHandler
        participant Cache as NettyCacheUtils
        participant Kafka
        participant Consumer as ExchangeTradeConsumer
        participant PushSvc as HawkPushServiceApi

        %% 订阅流程
        Client->>+Handler: 1. 发送订阅请求 (cmd=2001, body={symbol:"BTC/USDT"})
        Note over Handler: @HawkMethod(cmd=2001) 触发 subscribeExchange 方法
        Handler->>+Cache: 2. storeChannel("BTC/USDT", channel)
        Cache-->>-Handler: 3. 存储订阅关系
        Handler-->>-Client: 4. 返回订阅成功响应

        %% 推送流程
        Kafka-->>+Consumer: 5. 消费到一条 BTC/USDT 的新成交记录
        Consumer->>+Handler: 6. 调用 handleTrade("BTC/USDT", trade, thumb)
        
        Handler->>+Cache: 7. getChannel("BTC/USDT")
        Cache-->>-Handler: 8. 返回所有订阅了 "BTC/USDT" 的 Channel 列表
        
        Handler->>+PushSvc: 9. pushMsg(channels, PUSH_EXCHANGE_TRADE, trade)
        PushSvc-->>-Client: 10. **精准推送**最新成交数据
    ```

*   **核心推送代码 (`handleTrade` 方法)**:
    ```java
    // com.bizzan.bitrade.handler.NettyHandler
    
    @Autowired
    private HawkPushServiceApi hawkPushService;

    // 此方法由 ExchangeTradeConsumer 调用
    public void handleTrade(String symbol, ExchangeTrade exchangeTrade, CoinThumb thumb) {
        // 1. 推送全局 Ticker (广播给所有订阅了 "SYMBOL_THUMB" 的客户端)
        byte[] thumbBody = JSON.toJSONString(thumb).getBytes();
        hawkPushService.pushMsg(
            NettyCacheUtils.getChannel(topicOfSymbol), // topicOfSymbol = "SYMBOL_THUMB"
            NettyCommand.PUSH_SYMBOL_THUMB,
            thumbBody
        );

        // 2. 推送指定交易对的最新成交记录 (推送给所有订阅了 symbol 的客户端)
        byte[] tradeBody = JSONObject.toJSONString(exchangeTrade).getBytes();
        hawkPushService.pushMsg(
            NettyCacheUtils.getChannel(symbol),
            NettyCommand.PUSH_EXCHANGE_TRADE,
            tradeBody
        );
    }
    ```
*   **代码解读**:
    1.  `ExchangeTradeConsumer` 在消费到 Kafka 的成交消息并完成聚合计算后，调用 `NettyHandler.handleTrade` 方法。
    2.  `handleTrade` 方法根据业务需要，确定要推送的数据（`thumb`, `exchangeTrade`）和目标主题（`"SYMBOL_THUMB"`, `symbol`）。
    3.  它调用 `NettyCacheUtils.getChannel(topic)` 从内存订阅中心获取所有订阅了该主题的客户端 `Channel` 列表。
    4.  最后，通过 `hawkPushService.pushMsg` 将数据和对应的命令码（`cmd`）推送给目标 `Channel` 列表。

---

### 第五节：设计权衡与总结

通过剖析 AQMD-NETTY 框架，我们可以看到一个为特定高性能场景深度定制的解决方案。

*   **优点**:
    *   **高性能**: 直接基于 Netty 构建，拥有极高的吞吐量和低延迟，能轻松应对海量客户端连接。
    *   **协议精简**: 采用整数 `cmd` 作为命令码，相比基于字符串的 STOMP 协议，消息头部开销更小，解析效率更高。
    *   **灵活性高**: 自定义框架提供了最大的控制力，可以根据业务需求灵活地扩展协议和功能。

*   **缺点**:
    *   **非标准化**: 这是一个私有协议，需要客户端（Web, App）进行定制化开发来对接，不像 STOMP 有大量成熟的客户端库。
    *   **开发复杂性**: 相比 Spring Boot 提供的“开箱即用”的 WebSocket 支持，理解和维护这套自定义框架需要对 Netty 和网络编程有更深入的了解。

**总结**: 在金融交易这种对实时性和性能要求极致的场景下，选择基于 Netty 的自定义框架是一种典型的技术权衡。它通过牺牲一定的通用性和开发便捷性，换取了系统在核心性能指标上的显著优势。

至此，我们已经打通了数据从产生、处理、存储到最终实时触达用户的全链路。在下一章，我们将把目光投向整个系统的“血液”——**异步通信核心 Apache Kafka**，看看它是如何在这套复杂的微服务架构中扮演削峰填谷、服务解耦的关键角色的。
